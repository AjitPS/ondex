/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package net.sourceforge.ondex.server.plugins;

import java.lang.annotation.Annotation;
import java.util.Set;
import java.util.TreeSet;

import net.sourceforge.ondex.ONDEXPlugin;
import net.sourceforge.ondex.annotations.Authors;
import net.sourceforge.ondex.annotations.Custodians;
import net.sourceforge.ondex.annotations.DataURL;
import net.sourceforge.ondex.annotations.DatabaseTarget;
import net.sourceforge.ondex.annotations.Documentation;
import net.sourceforge.ondex.annotations.IncludeType;
import net.sourceforge.ondex.annotations.Status;
import net.sourceforge.ondex.annotations.StatusType;
import net.sourceforge.ondex.annotations.Webservice;
import net.sourceforge.ondex.annotations.metadata.AttributeNameRequired;
import net.sourceforge.ondex.annotations.metadata.DataSourceRequired;
import net.sourceforge.ondex.annotations.metadata.ConceptClassRequired;
import net.sourceforge.ondex.annotations.metadata.EvidenceTypeRequired;
import net.sourceforge.ondex.annotations.metadata.RelationTypeRequired;
import net.sourceforge.ondex.args.ArgumentDefinition;
import net.sourceforge.ondex.args.CompressResultsArguementDefinition;
import net.sourceforge.ondex.args.FileArgumentDefinition;
import net.sourceforge.ondex.export.ONDEXExport;
import net.sourceforge.ondex.filter.ONDEXFilter;
import net.sourceforge.ondex.mapping.ONDEXMapping;
import net.sourceforge.ondex.parser.ONDEXParser;
import net.sourceforge.ondex.transformer.ONDEXTransformer;
import net.sourceforge.ondex.wsapi.exceptions.CaughtException;
import net.sourceforge.ondex.wsapi.exceptions.PluginNotFoundException;
import net.sourceforge.ondex.wsapi.exceptions.WebserviceException;
import net.sourceforge.ondex.wsapi.plugins.PluginWS;
import net.sourceforge.ondex.wsapi.plugins.ZipFormat;
import org.apache.log4j.Logger;

/**
 *
 * @author Christian Brenninkmeijer
 */
public class AutoCreate extends PluginWS {

    private static final Logger logger = Logger.getLogger(AutoCreate.class);

    private PluginFinder pluginFinder = PluginFinder.getInstance();

    public AutoCreate() throws CaughtException{
        super();
        pluginFinder = PluginFinder.getInstance();
    }

    private static void writeTop(StringBuffer buffer, TypeOfPlugin pluginType) throws WebserviceException{
        buffer.append("/* Webservice wrapper of the ");
        buffer.append(pluginType.getCapital());
        buffer.append("plugins.");
        buffer.append(NEW_LINE);
        buffer.append("*");
        buffer.append(NEW_LINE);
        buffer.append("*/");
        buffer.append(NEW_LINE);
        buffer.append("//WARNING AUTOGENERATED DO NOT EDIT DIRECTLY AS EDITS WILL BE OVERWRITTED.");
        buffer.append(NEW_LINE);
        buffer.append(NEW_LINE);
    }

    private static void writePackage(StringBuffer buffer, TypeOfPlugin pluginType)
            throws WebserviceException{
        buffer.append("package net.sourceforge.ondex.server.plugins.");
        buffer.append(pluginType.getLower());
        buffer.append(";");
        buffer.append(NEW_LINE);
        buffer.append(NEW_LINE);
    }

    private static void writeSpecificImports(StringBuffer buffer, TypeOfPlugin pluginType)
            throws WebserviceException{
        switch (pluginType){
            case FILTER: {
            }case FILTERJOB: {
                buffer.append("import net.sourceforge.ondex.server.result.WSFilterResult;");
                buffer.append(NEW_LINE);
                break;
            } case PARSER: {
            } case PARSERJOB: {
            }case TRANSFORMER: {
            }case TRANSFORMERJOB: {
                break;
            }case EXPORTJOB: {
                buffer.append("import net.sourceforge.ondex.server.result.WSExportResult;");
                buffer.append(NEW_LINE);
                break;
            }case EXPORT: {
                break;
            }case MAPPING: {
            }case MAPPINGJOB: {
                break;
            } default: {
                throw new WebserviceException("Unexpected type in writeSpecificImports",logger);
            }
        }
        buffer.append(NEW_LINE);
        buffer.append(NEW_LINE);
    }

    private static void writeImports(StringBuffer buffer, TypeOfPlugin pluginType)
            throws WebserviceException{
        writeTop(buffer, pluginType);
        writePackage(buffer, pluginType);
        buffer.append("import net.sourceforge.ondex.ONDEXPluginArguments;");
        buffer.append(NEW_LINE);
        buffer.append("import net.sourceforge.ondex.core.ONDEXGraph;");
        buffer.append(NEW_LINE);
        buffer.append("import net.sourceforge.ondex.wsapi.exceptions.*;");
        buffer.append(NEW_LINE);
        buffer.append("import net.sourceforge.ondex.wsapi.plugins.ZipFormat;");
        buffer.append(NEW_LINE);
        buffer.append("import org.apache.log4j.Logger;");
        buffer.append(NEW_LINE);

        buffer.append("import javax.jws.WebMethod;");
        buffer.append(NEW_LINE);
        buffer.append("import javax.jws.WebParam;");
        buffer.append(NEW_LINE);
        buffer.append("import javax.jws.WebResult;");
        buffer.append(NEW_LINE);
        buffer.append("import java.io.File;");
        buffer.append(NEW_LINE);
        buffer.append("import java.io.StringWriter;");
        buffer.append(NEW_LINE);
        buffer.append("import net.sourceforge.ondex.server.plugins.");
        buffer.append(pluginType.getBase());
        buffer.append(";");
        buffer.append(NEW_LINE);
        buffer.append("import net.sourceforge.ondex.wsapi.exceptions.WebserviceException;");
        buffer.append(NEW_LINE);
        writeSpecificImports(buffer, pluginType);
        buffer.append(NEW_LINE);
    }

    private static void writeClassHead(StringBuffer buffer, TypeOfPlugin pluginType){
        buffer.append("/**");
        buffer.append(NEW_LINE);
        buffer.append("* AutoGenerated");
        buffer.append(NEW_LINE);
        buffer.append("* @author Christian Brenninkmeijer");
        buffer.append(NEW_LINE);
        buffer.append("*/");
        buffer.append(NEW_LINE);
        buffer.append("public class ");
        buffer.append(pluginType.getName());
        buffer.append("Auto extends ");
        buffer.append(pluginType.getBase());
        buffer.append("{ ");
        buffer.append(NEW_LINE);
        buffer.append(NEW_LINE);
        buffer.append("    private static final Logger logger = Logger.getLogger(");
        buffer.append(pluginType.getName());
        buffer.append("Auto.class);");
        buffer.append(NEW_LINE);
        buffer.append(NEW_LINE);
        buffer.append("    public ");
        buffer.append(pluginType.getName());
        buffer.append("Auto() throws CaughtException{");
        buffer.append(NEW_LINE);
        buffer.append("        super();");
        buffer.append(NEW_LINE);
        buffer.append("    }");
        buffer.append(NEW_LINE);
        buffer.append(NEW_LINE);
    }
    
    private static String scrub(String name){
        name = name.replace("?","");
        name = name.replace(".","_");
        name = name.replace("/","_");
        name = name.replace(" ","_");
        if (name.toLowerCase().indexOf("gds") >= 0){
            logger.info("GDS in " + name);
        }
        if (name.toLowerCase().indexOf("cv") >= 0){
            logger.info("CV in " + name);
        }
        if (name.toLowerCase().indexOf("context") >= 0){
            logger.info("CONTEXT in "+ name);
        }
        return name;
    }

    private static String commentScrub(String name){
        name = name.replace("*//","*");
        name = name.replace("*/","*");
        name = name.replace("//*","*");
        name = name.replace("/*","*");
        return name;
    }

    private static void  writePluginCompressionAttribute(StringBuffer buffer)
            throws WebserviceException{
        buffer.append ("     * @param compression");
        buffer.append(NEW_LINE);
        buffer.append(" 	 *           (Optional. Defaults to :false)");
        buffer.append("                  This Compression done within the plugin. The legal values are ");
        buffer.append(ZipFormat.legalValues());
        buffer.append(NEW_LINE);
    }

    private static void writeAttributeDoc(StringBuffer buffer, ArgumentDefinition<?> definition) throws WebserviceException{
        switch (getFileType(definition)){
            case INPUT_FILE:{
                writeInputFileAttributeDoc(buffer, definition);
                break;
            } case INPUT_DIRECTORY: {
                writeInputDirectoryAttributeDoc(buffer, definition);
                break;
            } case NONE: {
                writeSimpleAttributeDoc(buffer, definition);
                break;
            } case EXPORT_FILE: {
            } case EXPORT_DIRECTORY: {
                writePluginCompressionAttribute(buffer);
                break;
            } case COMPRESSION: {
                buffer.append ("     ////paramter ");
                buffer.append (definition.getName());
                buffer.append (" ignored as compression done by webservice.");
                buffer.append(NEW_LINE);
                break;
            } default: {
                throw new WebserviceException ("Method writeAttributeDoc missing code for "
                        +getFileType(definition), logger);
            }
        }
    }

    private static void  writeSimpleAttributeDoc(StringBuffer buffer, ArgumentDefinition<?> definition)
            throws WebserviceException{
        buffer.append ("     * @param ");
        buffer.append (scrub(definition.getName()));
        buffer.append(NEW_LINE);
        buffer.append(" 	 *            ");
        Object theDefault = definition.getDefaultValue();
        Boolean required = definition.isRequiredArgument();
        if (theDefault == null) {
            if (required){
                buffer.append("(REQUIRED! No Default!) ");
            } else
                buffer.append("(Optional. No Default.) ");
        } else {
            buffer.append("(Optional. Defaults to :");
            buffer.append(theDefault);
            buffer.append(") ");
        }
        Boolean multiple = definition.isAllowedMultipleInstances();
        if (multiple) {
            buffer.append("[List]");
        }
        buffer.append(commentScrub(definition.getDescription()));
        buffer.append(NEW_LINE);
    }

    private static void writeInputFileAttributeDoc(StringBuffer buffer,
            ArgumentDefinition<?> definition)
            throws WebserviceException{
        buffer.append ("     * @param ");
        buffer.append (scrub(definition.getName()));
        buffer.append("String");
        buffer.append(NEW_LINE);
            
        buffer.append(" 	 *            ");
        Boolean required = definition.isRequiredArgument();
        if (required){
            buffer.append("(REQUIRED!) ");
        } else{
            buffer.append("(Optional.) ");
        }
        Boolean multiple = definition.isAllowedMultipleInstances();
        if (multiple) {
            buffer.append("[List] ");
        }

        buffer.append("(Use this or ");
        buffer.append (scrub(definition.getName()));
        buffer.append("ByteArray NOT BOTH.) ");

        buffer.append(commentScrub(definition.getDescription()));
        buffer.append(NEW_LINE);

        buffer.append("     *        Legal values for the String are:");
        buffer.append(NEW_LINE);
        buffer.append("     *        1) Path and Name of a File Stored on the Server.");
        buffer.append(NEW_LINE);
        buffer.append("     *        2) Valid URL pointing to the file. (Traverna New Value)");
        buffer.append(NEW_LINE);
        buffer.append("     *        3) Valid URL pointing to a gzip file (as identified by \".gz\" ending. ");
        buffer.append(NEW_LINE);
        buffer.append("     *                 (Traverna New Value)");
        buffer.append(NEW_LINE);
        buffer.append("     *        4) Actaul String value. Avoid using this option if data is in a URL (use 3). ");
        buffer.append(NEW_LINE);
        buffer.append("     *                 (Traverna Add file location or Add URL)");
        buffer.append(NEW_LINE);

        buffer.append ("     * @param ");
        buffer.append (scrub(definition.getName()));
        buffer.append("ByteArray");
        buffer.append(NEW_LINE);

        buffer.append(" 	 *            ");
        if (required){
            buffer.append("(REQUIRED!) ");
        } else{
            buffer.append("(Optional.) ");
        }
        if (multiple) {
            buffer.append("[List]");
        }
        buffer.append("(Only used if ");
        buffer.append (scrub(definition.getName()));
        buffer.append("String is null or \"\".) GZip representation of ");
        buffer.append(commentScrub(definition.getDescription()));
        buffer.append(NEW_LINE);
     }

    private static void writeInputDirectoryAttributeDoc(StringBuffer buffer,
            ArgumentDefinition<?> definition)
            throws WebserviceException{
        buffer.append ("     * @param ");
        buffer.append (scrub(definition.getName()));
        buffer.append("String");
        buffer.append(NEW_LINE);

        buffer.append(" 	 *            ");
        Boolean required = definition.isRequiredArgument();
        if (required){
            buffer.append("(REQUIRED!) ");
        } else{
            buffer.append("(Optional.) ");
        }
        Boolean multiple = definition.isAllowedMultipleInstances();
        if (multiple) {
            buffer.append("[List] ");
        }

        buffer.append("(If ");
        buffer.append (scrub(definition.getName()));
        buffer.append("ByteArray is used the this will only serve to determine compression type.) ");

        buffer.append(commentScrub(definition.getDescription()));
        buffer.append(NEW_LINE);

        buffer.append("     *        Legal values for the String are:");
        buffer.append(NEW_LINE);
        buffer.append("     *        1) Path and Name of a Directory Stored on the Server. ");
        buffer.append(NEW_LINE);
        buffer.append("     *        2) Path and Name of a *.zip, *.tar, or *.tar.gz File Stored on the Server. ");
        buffer.append(NEW_LINE);
        buffer.append("     *        3) Valid URL pointing to a *.zip, *.tar or  *.tar.gz file. (Traverna New Value) ");
        buffer.append(NEW_LINE);
        buffer.append("     *        4) FTP address which can be a directory or a single *.zip, *.tar or  *.tar.gz file.");
        buffer.append(" (Traverna New Value)");
        buffer.append(NEW_LINE);
        buffer.append("     *        5) Format of the ByteArray \"zip\", \"tar\" or  \"tar.gz\".");
        buffer.append(" Using any other value which does not end in these literals will cause an Exception if");
        buffer.append(" ByteArray is not null or empty.");
        buffer.append(NEW_LINE);

        buffer.append ("     * @param ");
        buffer.append (scrub(definition.getName()));
        buffer.append("ByteArray");
        buffer.append(NEW_LINE);

        buffer.append(" 	 *            ");
        if (required){
            buffer.append("(REQUIRED!) ");
        } else{
            buffer.append("(Optional.) ");
        }
        if (multiple) {
            buffer.append("[List]");
        }
        buffer.append("Expects ");
        buffer.append (scrub(definition.getName()));
        buffer.append("String to describe format. Options are \"zip\" and \"tar.gz\".");
        buffer.append(commentScrub(definition.getDescription()));
        buffer.append(NEW_LINE);
     }

    private static void writeStringArray(StringBuffer buffer, String[] array){
        for (String single:array){
            buffer.append(single);
            buffer.append(", ");
        }
    }

    private static void writeAnnotationsDocs(StringBuffer buffer, Annotation[] annotations){
        for(Annotation annotation: annotations){
            if (annotation instanceof Authors){
                Authors authors = (Authors)annotation;
                buffer.append(" 	 *    Authors: ");
                writeStringArray(buffer,authors.authors());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof Custodians){
                Custodians custodians  = (Custodians)annotation;
                buffer.append(" 	 *    Custodians: ");
                writeStringArray(buffer,custodians.custodians());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof DataURL){
                DataURL dataUrl  = (DataURL)annotation;
                buffer.append(" 	 *    DataURL: ");
                buffer.append(dataUrl.name());
                buffer.append(" ");
                buffer.append(dataUrl.description());
                buffer.append(" ");
                buffer.append(dataUrl.urls());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof DatabaseTarget){
                DatabaseTarget databaseTarget  = (DatabaseTarget)annotation;
                buffer.append(" 	 *    DatabaseTarget: ");
                buffer.append(databaseTarget.name());
                buffer.append(" ");
                buffer.append(databaseTarget.url());
                buffer.append(" ");
                buffer.append(databaseTarget.description());
                buffer.append(" ");
                buffer.append(databaseTarget.version());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof Documentation){
                Documentation documentation = (Documentation)annotation;
                buffer.append(" 	 *    Documentation: ");
                buffer.append(documentation.url());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof Status){
                Status status = (Status)annotation;
                buffer.append(" 	 *    Status: ");
                buffer.append(status.status());
                buffer.append(" ");
                buffer.append(status.description());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof AttributeNameRequired){
                AttributeNameRequired required = (AttributeNameRequired)annotation;
                buffer.append("AttributeNameRequired: ");
                writeStringArray(buffer,required.ids());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof DataSourceRequired){
                DataSourceRequired required = (DataSourceRequired)annotation;
                buffer.append("AttributeNameRequired: ");
                writeStringArray(buffer,required.ids());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof ConceptClassRequired){
                ConceptClassRequired required = (ConceptClassRequired)annotation;
                buffer.append("ConceptClassRequired: ");
                writeStringArray(buffer,required.ids());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof EvidenceTypeRequired){
                EvidenceTypeRequired required = (EvidenceTypeRequired)annotation;
                buffer.append("EvidenceTypeRequired: ");
                writeStringArray(buffer,required.ids());
                buffer.append(NEW_LINE);
            } else if (annotation instanceof RelationTypeRequired){
                RelationTypeRequired required = (RelationTypeRequired)annotation;
                buffer.append("RelationTypeRequired: ");
                writeStringArray(buffer,required.ids());
                buffer.append(NEW_LINE);
            }
        }
    }

    private static void writeNoneJobReturnDocs(StringBuffer buffer, ArgumentDefinition<?>[] argumentDefinitions, 
            String name, TypeOfPlugin pluginType) throws WebserviceException{
        switch (getFileType(argumentDefinitions)){
            case NONE:
            case INPUT_FILE:
            case INPUT_DIRECTORY:
                buffer.append("     * @return String representation of all event fired by the ");
                buffer.append(pluginType.getLower());
                buffer.append(NEW_LINE);
                break;
            case EXPORT_FILE:
                buffer.append("     * @return Content of a small file as a String or Url as per compression parameter. ");
                buffer.append(NEW_LINE);
                break;
            case EXPORT_DIRECTORY:
                buffer.append("     * @return Url as per compression parameter. ");
                buffer.append(NEW_LINE);
                break;
            default:
                throw new WebserviceException("Unable to handle plugin " + name + " because it has file type of " +
                        getFileType(argumentDefinitions), logger);
        }
    }

    private static void writeMethodDocs(StringBuffer buffer,
            ArgumentDefinition<?>[] argumentDefinitions ,Annotation[] annotations,
            String name, TypeOfPlugin pluginType) throws WebserviceException{
        buffer.append("     /**");
        buffer.append(NEW_LINE);
        buffer.append("     * Method to run ");
        buffer.append(pluginType.getCapital());
        buffer.append(" in ");
        buffer.append(name);
        buffer.append(" package.");
        buffer.append(NEW_LINE);
        buffer.append("     *");
        buffer.append(NEW_LINE);
        writeAnnotationsDocs(buffer, annotations);
        boolean compressionAdded = false;
        for (ArgumentDefinition<?> definition: argumentDefinitions){
            writeAttributeDoc(buffer, definition);
        }
        buffer.append("     * @param graphId");
        buffer.append(NEW_LINE);
        buffer.append(" 	 *            (REQUIRED! No Default!) The ID of the Graph");
        buffer.append(NEW_LINE);

        switch (pluginType){
            case FILTER:
            case PARSER:
            case TRANSFORMER:               
            case EXPORT:
            case MAPPING:
                writeNoneJobReturnDocs(buffer, argumentDefinitions, name, pluginType);
                break;
            case FILTERJOB:
            case PARSERJOB:
            case MAPPINGJOB:
            case TRANSFORMERJOB:
                buffer.append("     * @return The JobID. (Taverna users need a single XML Splitter");
                buffer.append(NEW_LINE);
                break;                
            case EXPORTJOB:
                buffer.append("     * @return WSExportResult. Complex return of the URL to which the file will be written and the JobID. (Taverna users need two XML Splitters");
                buffer.append(NEW_LINE);
                break;
        }

        buffer.append("     * @throws WebserviceException");
        buffer.append(NEW_LINE);
        buffer.append("     */");
        buffer.append(NEW_LINE);
    }

    private static void writeWebResult(StringBuffer buffer, ArgumentDefinition<?>[] argumentDefinitions, String name,
            TypeOfPlugin pluginType) throws WebserviceException{
        switch (pluginType){
            case FILTER:
            case PARSER:
            case TRANSFORMER:
            case EXPORT:
            case MAPPING:
                switch (getFileType(argumentDefinitions)){
                    case NONE:
                    case INPUT_FILE:
                    case INPUT_DIRECTORY:
                        buffer.append("    @WebResult(name = \"info\")");
                        buffer.append(NEW_LINE);
                        break;
                    case EXPORT_FILE:
                        buffer.append("    @WebResult(name = \"output\")");
                        buffer.append(NEW_LINE);
                        break;
                    case EXPORT_DIRECTORY:
                        buffer.append("    @WebResult(name = \"url\")");
                        buffer.append(NEW_LINE);
                        break;
                    default:
                        throw new WebserviceException("Unable to handle plugin " + name + " because it has file type of " +
                            getFileType(argumentDefinitions), logger);
                    }
                break;
            case FILTERJOB:
            case MAPPINGJOB:
            case PARSERJOB:
            case TRANSFORMERJOB:
                buffer.append("    @WebResult(name = \"jobId\")");
                buffer.append(NEW_LINE);
                break;
            case EXPORTJOB:
                buffer.append("    @WebResult(name = \"wsExportResult\")");
                buffer.append(NEW_LINE);
                break;
        }
    }

    private static void writeMethodName(StringBuffer buffer, ArgumentDefinition<?>[] argumentDefinitions, String name, 
            TypeOfPlugin pluginType) throws WebserviceException{
        writeWebResult(buffer, argumentDefinitions, name, pluginType);
        buffer.append(NEW_LINE);
        buffer.append("    @WebMethod(exclude = false)");
        buffer.append(NEW_LINE);
        buffer.append("    public ");
        buffer.append(pluginType.getReturnType());
        buffer.append(" ");
        buffer.append(scrub(name));
        buffer.append(pluginType.getCapital());
    }

    private static void writeAttributeDeclaration (StringBuffer buffer,
            ArgumentDefinition<?> definition)
            throws WebserviceException{
        //ogger.info("writeAttributeDeclaration "+name+ " "+definition);
        //ogger.info(type);
        //ogger.info(type.compareTo(TypeOfMethod.INDIVIDUAL_STRING));
        switch (getFileType(definition)){
            case INPUT_FILE:{
                //Same as READER
            } case INPUT_DIRECTORY: {
                buffer.append("           @WebParam(name = \"");
                buffer.append (scrub(definition.getName()));
                buffer.append("String\") String ");
                buffer.append (scrub(definition.getName()));
                buffer.append("String,");
                buffer.append(NEW_LINE);

                buffer.append("           @WebParam(name = \"");
                buffer.append (scrub(definition.getName()));
                buffer.append("ByteArray\") byte[] ");
                buffer.append (scrub(definition.getName()));
                buffer.append("ByteArray,");
                buffer.append(NEW_LINE);
                break;
            } case EXPORT_FILE: {
            } case EXPORT_DIRECTORY: {
                buffer.append("           @WebParam(name = \"compression\") java.lang.String compression,");
                buffer.append(NEW_LINE);
                break;
            } case COMPRESSION: {
                buffer.append ("     ////paramter ");
                buffer.append (definition.getName());
                buffer.append (" ignored as compression done by webservice.");
                buffer.append(NEW_LINE);
                break;
            } case NONE: {
                buffer.append("           @WebParam(name = \"");
                buffer.append (scrub(definition.getName()));
                buffer.append("\")");
                buffer.append(definition.getClassType().getName());
                Boolean multiple = definition.isAllowedMultipleInstances();
                if (multiple) {
                    buffer.append("[]");
                }
                buffer.append(" ");
                buffer.append (scrub(definition.getName()));
                buffer.append(",");
                buffer.append(NEW_LINE);
                break;
            } default: {
                throw new WebserviceException ("Method writeAttributeDeclaration missing code for "
                        +getFileType(definition), logger);
            }
        }
    }
    
    private static void writeMethodDeclaration(StringBuffer buffer,
            ArgumentDefinition<?>[] argumentDefinitions ,String name,
            TypeOfPlugin pluginType) throws WebserviceException{
        writeMethodName(buffer, argumentDefinitions, name, pluginType);
        buffer.append("(");
        buffer.append(NEW_LINE);
        for (ArgumentDefinition<?> definition: argumentDefinitions){
            writeAttributeDeclaration(buffer, definition);
        }
        buffer.append("           @WebParam(name = \"graphId\") Long graphId)");
        buffer.append(NEW_LINE);
        buffer.append("           throws WebserviceException {");
        buffer.append(NEW_LINE);
    }

    private void writeMethodBody(StringBuffer buffer,
            ArgumentDefinition<?>[] argumentDefinitions ,String name,
            TypeOfPlugin pluginType) throws WebserviceException{
        writeMethodBodyLoadPlugin(buffer, name, pluginType);
        writeMethodBodyGetGraphAndArguments (buffer, pluginType);
        boolean output = writeMethodBodyLoadArguements(buffer, argumentDefinitions, name, pluginType);
        writeMethodBodyRun(buffer, pluginType, output);
        writeMethodBodyCatches(buffer);
    }

    private void writeMethodBodyLoadPlugin(StringBuffer buffer, String name, TypeOfPlugin pluginType)
            throws CaughtException, PluginNotFoundException{
        buffer.append("        try{");
        buffer.append(NEW_LINE);

        buffer.append("           logger.info(\"");
        buffer.append(pluginType.getLower());
        buffer.append(" ");
        buffer.append(name);
        buffer.append(" called\");");
        buffer.append(NEW_LINE);

        String className = pluginFinder.getClassName(name, pluginType);
        buffer.append("           ");
        buffer.append(className);
        buffer.append(" ");
        buffer.append(pluginType.getLower());
        buffer.append(" =");
        buffer.append(NEW_LINE);
        buffer.append("                   new ");
        buffer.append(className);
        buffer.append("();");
        buffer.append(NEW_LINE);
        buffer.append("           logger.info(\");");
        buffer.append(pluginType.getCapital());
        buffer.append(" created \"+");
        buffer.append(pluginType.getLower());
        buffer.append(");");
        buffer.append(NEW_LINE);
    }

    private void writeMethodBodyGetGraphAndArguments (StringBuffer buffer, TypeOfPlugin pluginType){
        buffer.append("           ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);");
        buffer.append(NEW_LINE);
        buffer.append("           logger.info(\"found graph\");");
        buffer.append(NEW_LINE);
        buffer.append("           ONDEXPluginArguments arguments = new ONDEXPluginArguments(");
        buffer.append(pluginType.getLower());
        buffer.append(".getArgumentDefinitions());");
        buffer.append(NEW_LINE);
    }

    private boolean writeMethodBodyLoadArguements(StringBuffer buffer, ArgumentDefinition<?>[] argumentDefinitions,
            String name, TypeOfPlugin pluginType) throws WebserviceException{
        boolean output = false;
        for (ArgumentDefinition<?> definition: argumentDefinitions){
            switch (getFileType(definition)){
                case INPUT_FILE:{
                    writeMethodBodyInputFileArguement(buffer, pluginType, definition);
                    break;
                } case INPUT_DIRECTORY:{
                    writeMethodBodyInputDirectoryArguement(buffer, pluginType, definition);
                    break;
                } case EXPORT_FILE:{
                    output = uniqueOutut(output, name);
                    writeMethodBodyExportFileArguement(buffer, pluginType, definition);
                    break;
                } case EXPORT_DIRECTORY:{
                    output = uniqueOutut(output, name);
                    writeMethodBodyExportDirectoryArguement(buffer, pluginType, definition);
                    break;
                } case COMPRESSION:{
                    writeMethodBodySetCompressionFalse(buffer, pluginType, definition);
                    break;
                } case NONE: {
                    writeMethodBodyNonFileArguement(buffer, pluginType, definition);
                    break;
                } default: {
                    throw new WebserviceException("Unexpected file type in writeMethodBody", logger);
                }
            }
            //do NOT scrub this one. Must match the one in plugin
        }
        buffer.append("           logger.info(\"created arguements\");");
        buffer.append(NEW_LINE);
        return output;
    }

    private void writeMethodBodyInputFileArguement(StringBuffer buffer, TypeOfPlugin pluginType, ArgumentDefinition<?> definition){
        if (definition.isRequiredArgument()){
            buffer.append("           createInputFileArguement(");
        } else {
            buffer.append("           createOptionalInputFileArguement(");
        }
        buffer.append(pluginType.getLower());
        buffer.append(", arguments, \"");
        buffer.append(scrub(definition.getName()));
        buffer.append("\", ");
        buffer.append(scrub(definition.getName()));
        buffer.append("String, ");
        buffer.append(scrub(definition.getName()));
        buffer.append("ByteArray);");
        buffer.append(NEW_LINE);
    }

    private void writeMethodBodyInputDirectoryArguement(StringBuffer buffer, TypeOfPlugin pluginType, ArgumentDefinition<?> definition){
        if (definition.isRequiredArgument()){
            buffer.append("           createInputDirectoryArguement(");
        } else {
            buffer.append("           createOptionalInputDirectoryArguement(");
        }
        buffer.append(pluginType.getLower());
        buffer.append(", arguments, \"");
        buffer.append(scrub(definition.getName()));
        buffer.append("\", ");
        buffer.append(scrub(definition.getName()));
        buffer.append("String, ");
        buffer.append(scrub(definition.getName()));
        buffer.append("ByteArray);");
        buffer.append(NEW_LINE);
    }

    private boolean uniqueOutut(boolean output,  String name) throws WebserviceException{
        if (output) {
            throw new WebserviceException("Unable to handle two outputs in " + name, logger);
        }
        return true;
    }

    private void writeMethodBodyExportFileArguement(StringBuffer buffer, TypeOfPlugin pluginType, ArgumentDefinition<?> definition){
        buffer.append("           ZipFormat zipFormat = ZipFormat.parseString(compression);");
        buffer.append(NEW_LINE);
        buffer.append("           File output = createOutputFile(\"output\",\".xml\");");
        buffer.append(NEW_LINE);
        buffer.append("           addExportFile(");
        buffer.append(pluginType.getLower());
        buffer.append(", \"");
        buffer.append(definition.getName());
        buffer.append("\", arguments, output);");
        buffer.append(NEW_LINE);
    }

    private void writeMethodBodyExportDirectoryArguement(StringBuffer buffer, TypeOfPlugin pluginType, ArgumentDefinition<?> definition){
        buffer.append("           ZipFormat zipFormat = ZipFormat.parseString(compression);");
        buffer.append(NEW_LINE);
        buffer.append("           File output = createTempDirectory();");
        buffer.append(NEW_LINE);
        buffer.append("           addExportDir(export, arguments, output);");
        buffer.append(NEW_LINE);
    }

    private void writeMethodBodySetCompressionFalse(StringBuffer buffer, TypeOfPlugin pluginType, ArgumentDefinition<?> definition){
        buffer.append("           createArguement(");
        buffer.append(pluginType.getLower());
        buffer.append(", arguments, \"");
        buffer.append(definition.getName());
        buffer.append("\", false);" );
        buffer.append(NEW_LINE);
    }

    private void writeMethodBodyNonFileArguement(StringBuffer buffer, TypeOfPlugin pluginType, ArgumentDefinition<?> definition){
        buffer.append("           createArguement(");
        buffer.append(pluginType.getLower());
        buffer.append(", arguments, \"");
        buffer.append(definition.getName());
        buffer.append("\", ");
        buffer.append(scrub(definition.getName()));
        buffer.append(");");
        buffer.append(NEW_LINE);
    }

    private void writeMethodBodyRun(StringBuffer buffer, TypeOfPlugin pluginType, boolean output) throws WebserviceException{
        switch (pluginType){
            case EXPORTJOB:
                buffer.append("          ExportJob job = new ExportJob(graph, output, export, arguments);");
                buffer.append(NEW_LINE);
                buffer.append("          return new WSExportResult(job);");
                buffer.append(NEW_LINE);
                break;
            case FILTERJOB:
            case PARSERJOB:
            case MAPPINGJOB:
            case TRANSFORMERJOB:
                buffer.append("           ");
                buffer.append(pluginType.getCapital());
                buffer.append("Job job = new ");
                buffer.append(pluginType.getCapital());
                buffer.append("Job(graph, ");
                buffer.append(pluginType.getLower());
                buffer.append(", arguments);");
                buffer.append(NEW_LINE);
                buffer.append("           return job.getJobId().toString();");
                buffer.append(NEW_LINE);
                break;
            case EXPORT:
            case FILTER:
            case MAPPING:
            case PARSER:
            case TRANSFORMER:
                buffer.append("           return run");
                buffer.append(pluginType.getCapital());
                buffer.append("(graph, ");
                if (output) {
                    buffer.append("output, ");
                }
                buffer.append(pluginType.getLower());
                buffer.append(", arguments");
                if (output){
                    buffer.append(", zipFormat");
                }
                buffer.append(");");
                buffer.append(NEW_LINE);
                break;
            default:
                throw new WebserviceException("Unexpected file type in writeMethodBody", logger);
        }
    }

    private void writeMethodBodyCatches(StringBuffer buffer){
        buffer.append("        } catch (WebserviceException e)   {");
        buffer.append(NEW_LINE);
        buffer.append("            throw e;");
        buffer.append(NEW_LINE);
        buffer.append("        } catch (Exception e)    {");
        buffer.append(NEW_LINE);
        buffer.append("            throw new CaughtException (e, logger);");
        buffer.append(NEW_LINE);
        buffer.append("        }");
        buffer.append(NEW_LINE);
        buffer.append("    } //WARNING AUTOGENERATED DO NOT EDIT DIRECTLY AS EDITS WILL BE OVERWRITTED.");
        buffer.append(NEW_LINE);
        buffer.append(NEW_LINE);
    }

    public static TypeOfFile getFileType(ArgumentDefinition<?> definition){
        if (definition instanceof FileArgumentDefinition) {
            if (definition.getName().equals(FileArgumentDefinition.INPUT_FILE)){
                return TypeOfFile.INPUT_FILE;
            }
            if (definition.getName().equals(FileArgumentDefinition.INPUT_DIR)){
                return TypeOfFile.INPUT_DIRECTORY;
            }
            if (definition.getName().equals(FileArgumentDefinition.EXPORT_FILE)){
                return TypeOfFile.EXPORT_FILE;
            }
            if (definition.getName().equals(FileArgumentDefinition.EXPORT_DIR)){
                return TypeOfFile.EXPORT_DIRECTORY;
            }
            FileArgumentDefinition fileArgumentDefinition = (FileArgumentDefinition)definition;
            boolean dir = fileArgumentDefinition.isDirectory();
            boolean input = fileArgumentDefinition.isPreExisting();
            if (dir) {
                if (input) {
                    return TypeOfFile.INPUT_DIRECTORY;
                } else {
                    return TypeOfFile.EXPORT_DIRECTORY;
                }
            } else {
                if (input) {
                    return TypeOfFile.INPUT_FILE;
                } else {
                    return TypeOfFile.EXPORT_FILE;                
                }
            }
        }
        if (definition instanceof CompressResultsArguementDefinition) {
             return TypeOfFile.COMPRESSION;
        }
        return TypeOfFile.NONE;
    }
 
   public static TypeOfFile getFileType(ArgumentDefinition<?>[] argumentDefinitions) throws WebserviceException{
        TypeOfFile found = TypeOfFile.NONE;
        for (ArgumentDefinition<?> definition: argumentDefinitions){
            TypeOfFile thisOne = getFileType(definition);
            switch (thisOne){
                case NONE:
                    //keep existing result;
                    break;
                case COMPRESSION:
                    //Will be ignored
                    break;
                case INPUT_FILE:
                    switch (found){
                        case NONE:
                        case INPUT_FILE:
                            found = TypeOfFile.INPUT_FILE;
                            break;
                        case INPUT_DIRECTORY:
                        case EXPORT_FILE:
                        case EXPORT_DIRECTORY:
                            //leave as is as can mix input with output
                    }
                    break;
                case INPUT_DIRECTORY:
                    switch (found){
                        case NONE:
                        case INPUT_FILE:
                        case INPUT_DIRECTORY:
                            found = TypeOfFile.INPUT_DIRECTORY;
                            break;
                        case EXPORT_FILE:
                        case EXPORT_DIRECTORY:
                            //leave as is as can mix input with output
                    }
                    break;
                case EXPORT_FILE:
                    switch (found){
                        case NONE:
                        case INPUT_FILE:
                        case INPUT_DIRECTORY:
                        case EXPORT_FILE:
                            found = TypeOfFile.EXPORT_FILE;
                            break;
                        case EXPORT_DIRECTORY:
                            found = TypeOfFile.MULTIPLE;
                    }
                    break;
                case EXPORT_DIRECTORY:
                    switch (found){
                        case NONE:
                        case INPUT_FILE:
                        case INPUT_DIRECTORY:
                        case EXPORT_DIRECTORY:
                            found = TypeOfFile.EXPORT_DIRECTORY;
                            break;
                        case EXPORT_FILE:
                            found = TypeOfFile.MULTIPLE;
                    }
                    break;
                default: throw new WebserviceException ("Unexpected TypeOfFile in getTypeOfFile", logger);
             }
        }
        return found;
    }

   private void writeMethod(StringBuffer buffer, String name, TypeOfPlugin pluginType)
            throws CaughtException, PluginNotFoundException, WebserviceException {
        Annotation[] annotations = getDeclaredAnnotations(name, pluginType);
        IncludeType include = getWebserviceInclude(annotations);
        if (IncludeType.NEVER.equals(include)){
            buffer.append("//Ignoring plugin with Webservice include Never annotation "+pluginType.getLower()+" "+name);
            buffer.append(NEW_LINE);
        } else if (IncludeType.ALWAYS.equals(include)){
            writeMethod(buffer, name, pluginType, annotations);
        } else {
            StatusType status = getStatus(annotations);
            if (status == null){
                buffer.append("//Ignoring plugin without status "+pluginType.getLower()+" "+name);
                buffer.append(NEW_LINE);
            } else {
                switch (status){
                    case DISCONTINUED:
                        buffer.append("//Ignoring discontinuted plugin "+pluginType.getLower()+" "+name);
                        buffer.append(NEW_LINE);
                        break;
                    case EXPERIMENTAL:
                        buffer.append("//Ignoring experimental plugin "+pluginType.getLower()+" "+name);
                        buffer.append(NEW_LINE);
                        break;
                    case STABLE:
                        writeMethod(buffer, name, pluginType, annotations);
                        break;
                    default:
                        throw new WebserviceException("Unexpected Status type for plugin " + name, logger);
                }
            }
        }
    }

    private void writeMethod(StringBuffer buffer, String name, TypeOfPlugin pluginType, Annotation[] annotations)
            throws CaughtException, PluginNotFoundException, WebserviceException{
        ArgumentDefinition<?>[] argumentDefinitions =getArgumentDefinitions(name, pluginType);
        writeMethodDocs(buffer, argumentDefinitions, annotations, name, pluginType);
        writeMethodDeclaration(buffer, argumentDefinitions, name, pluginType);
        writeMethodBody(buffer, argumentDefinitions, name, pluginType);
    }

    private static ArgumentDefinition<?>[] getArgumentDefinitions
            (String name, TypeOfPlugin pluginType) 
            throws CaughtException, PluginNotFoundException, WebserviceException{
        PluginFinder pluginFinder = PluginFinder.getInstance();
        switch (pluginType){
            case FILTER: {
            } case FILTERJOB: {
                ONDEXFilter filter = pluginFinder.getFilter(name);
                return filter.getArgumentDefinitions();
            } case PARSER: {
            } case PARSERJOB: {
                ONDEXParser parser = pluginFinder.getParser(name);
                return parser.getArgumentDefinitions();
            }case TRANSFORMER: {
            }case TRANSFORMERJOB: {
                ONDEXTransformer transformer = pluginFinder.getTransformer(name);
                return transformer.getArgumentDefinitions();
            }case EXPORT: {
            }case EXPORTJOB: {
                ONDEXExport export = pluginFinder.getExport(name);
                return export.getArgumentDefinitions();
            }case MAPPING: {
            }case MAPPINGJOB: {
                ONDEXMapping mapping = pluginFinder.getMapping(name);
                return mapping.getArgumentDefinitions();
            } default: {
                throw new WebserviceException("Unexpected type in getArgumentDefinitions "+ pluginType,logger);
            }
        }
    }

    private Annotation[] getDeclaredAnnotations(String name, TypeOfPlugin pluginType)
            throws CaughtException, PluginNotFoundException, WebserviceException{
        PluginFinder pluginFinder = PluginFinder.getInstance();
        ONDEXPlugin plugin;
        switch (pluginType){
            case FILTER: {
            } case FILTERJOB: {
                plugin = pluginFinder.getFilter(name);
                break;
            } case PARSER: {
            } case PARSERJOB: {
                plugin = pluginFinder.getParser(name);
                break;
            }case TRANSFORMER: {
            }case TRANSFORMERJOB: {
                plugin = pluginFinder.getTransformer(name);
                break;
            }case EXPORT: {
            }case EXPORTJOB: {
                plugin = pluginFinder.getExport(name);
                break;
            }case MAPPING: {
            }case MAPPINGJOB: {
                plugin = pluginFinder.getMapping(name);
                break;
            } default: {
                throw new WebserviceException("Unexpected type in getDeclaredAnnotations " + pluginType,logger);
            }
        }
        return plugin.getClass().getDeclaredAnnotations();
    }

    public static StatusType getStatus(Annotation[] annotations){
        for(Annotation annotation: annotations){
            if (annotation instanceof Status){
                Status status = (Status)annotation;
                return status.status();
            }
        }
        return null;
    }

    public static IncludeType getWebserviceInclude (Annotation[] annotations){
        for(Annotation annotation: annotations){
            if (annotation instanceof Webservice){
                Webservice webservice = (Webservice)annotation;
                return webservice.include();
            }
        }
        return null;
    }

    public static Set<String> getPlugins(TypeOfPlugin pluginType) throws WebserviceException{
        PluginFinder pluginFinder = PluginFinder.getInstance();
        switch (pluginType){
            case FILTER: 
            case FILTERJOB: {
                 return pluginFinder.getFilterNames();
            }
            case PARSER:
            case PARSERJOB: {
                 return pluginFinder.getParserNames();
            }
            case TRANSFORMER:
            case TRANSFORMERJOB: {
                 return pluginFinder.getTransformerNames();
            }
            case EXPORT:
            case EXPORTJOB: {
                 return pluginFinder.getExportNames();
            }
            case MAPPING:
            case MAPPINGJOB: {
                 return pluginFinder.getMappingNames();
            } default: {
                throw new WebserviceException("Unexpected type in getPlugins " +  pluginType.getName(),logger);
            }
        }
    }

    public String wholeClass(TypeOfPlugin pluginType) 
            throws CaughtException, PluginNotFoundException, WebserviceException{   
        TreeSet<String> plugins = new TreeSet(getPlugins(pluginType));
       try{
            StringBuffer buffer  = new StringBuffer();
            writeImports(buffer, pluginType);
            writeClassHead(buffer, pluginType);
            for (String name: plugins){
                //if (name.equals("metadatacount")) {
                //    buffer.append("////Ignoring " + name + " due to Multiple Output files.");
                //    buffer.append(NEW_LINE);
                //    buffer.append(NEW_LINE);
                //} else {
                    writeMethod(buffer,name, pluginType);
                //}
            }
            buffer.append("}");
            return buffer.toString();
       } catch (WebserviceException e){
           throw e;
       } catch (Exception e){
           throw new CaughtException ("creating "+pluginType.getName() + "Auto",e, logger);
       }
   }

}
