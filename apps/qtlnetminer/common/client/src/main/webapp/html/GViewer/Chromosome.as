/*Need to pass/get number of chromosomes from parent objectrather than have it hard coded into this file.the scale factor also needs to be calculated more correctly*/class Chromosome extends MovieClip {	public var parentObj:Object;	public var chromosome:String;	public var chrSpacing:Number = 0;	public var chrWidth:Number = 0;	public var qtlWidth:Number = 10;	public var _x = 10;	public var _y = 0;	public var homeX:Number = 0;	public var homeY:Number = 0;	public var qtlPosition:String = "offset";	private var featureList:Array;	private var outLinkList:Array; // list of objects that link out of this chromosome	private var inLinkList:Array; // list of objects that link into this chromosome	public var tmpFeatureArray:Array = new Array();	public var scaleFactor:Number = 1500000;	public var chr_length:Number = 0;	public var isZoomed:String = "no";	public var isRotated:String = "no";	private var featureDrawIndex:Number;	public var tickSpacing:Number = 500000;	public var isHomePosition = Boolean(false);	public var linkURL:String = "";	public var number_txt:Object;	public var bar:BarSelector;	public static function createChromosome(target:MovieClip, depth:Number, x:Number, y:Number, chr:String, linkUrl:String, length:Number, chrsPerRow:Number):Chromosome {		trace("Chromosome created for: " + chr);		trace("Chromosome attaching to : " + target._name + "Root: " + _root._name);		var chrom:Chromosome = 		Chromosome(target.attachMovie("Chromosome","Chromosome_" + chr + "_" + depth, depth));		chrom.init(target, x, y, chr, linkUrl, length, chrsPerRow); // initialize the object		return chrom;	}	public function init(target:MovieClip, x:Number, y:Number, chr:String, linkUrl:String, length:Number, chrsPerRow:Number) {		this.parentObj = target;		this._x = x;		this._y = y;		this.chromosome = chr;		this.linkURL = linkURL;		this.chr_length = length;			this.featureList = new Array();		this.outLinkList = new Array();		this.inLinkList = new Array();		this.chrSpacing = (Stage.width/chrsPerRow)*.7; // 25;		this.chrWidth = (Stage.width/chrsPerRow)*.3;		// this._y = (Stage.width/chrsPerRow)*.5;		trace("Chromosome attached " + this._name + " to: " + _parent._name);	}	public function addFeature(feature:Feature):Void {		featureList.push(feature);		trace("Feature added to " +this._name + ", we have " + featureList.length + " features for this chromosome");	}	public function addOutLink(obj:Object):Void {		this.outLinkList.push(obj);		trace("outlink added to " +this._name + ", we have " + this.outLinkList.length + " outlinks for this chromosome");	}	public function addInLink(obj:Object):Void {		this.inLinkList.push(obj);		trace("inlink added to " +this._name + ", we have " + this.inLinkList.length + " inlinks for this chromosome");	}	public function sortFeaturesByType(a:Feature,b:Feature):Number {		var featureType1:String = a.type;		var featureType2:String = b.type;		if(featureType1 < featureType2) {			return -1;			} else if (featureType1 > featureType2) {				return 1;			}			else {				return 0;			}	}	public function drawLinkLine(startObj,endObj,color,style) {		// convert local coords to global		trace("start width: " + startObj._width);		var start_point:Object = {x:startObj._width, y:startObj._height/2};		var end_point:Object;		startObj.localToGlobal(start_point);		end_point = {x:endObj._width, y:endObj._height/2};		endObj.localToGlobal(end_point);		_root.link_layer.lineStyle(0, color, 75);		// if we are linking to this same chromosome, use a curve, not a line		if((startObj.chromosome == endObj.chromosome) || (Math.abs(start_point.x - end_point.x) < 10) ) {			_root.link_layer.moveTo(start_point.x, start_point.y);			if( (this.isZoomed == "yes") && (startObj.chromosome != endObj.chromosome) ) {				var y_loc = (((Stage.height-30)/_root.chromosomeList.length)*_root.chromosomeNameToIndex[endObj.chromosome])+30;				end_point = {x:Stage.width-30, y:y_loc};				this.polygon(_root.link_layer,Stage.width-30,y_loc,6,10,0); 			}			var control_y:Number;			if(start_point.y < end_point.y) {				control_y = start_point.y + (end_point.y - start_point.y)/2;			}			else {				control_y = end_point.y + (start_point.y - end_point.y)/2;			}			var control_x:Number;			// draw the control point based on the right most feature			if(start_point.x > end_point.x) {				control_x = start_point.x + 30; // arbitrary value for now			}			else {				control_x = end_point.x + 30;			}			_root.link_layer.curveTo(control_x, control_y,end_point.x, end_point.y);		}		else {			if(this.isZoomed == "yes") {				var y_loc = (((Stage.height-30)/_root.chromosomeList.length)*_root.chromosomeNameToIndex[endObj.chromosome])+30;				end_point = {x:Stage.width-30, y:y_loc};				this.polygon(_root.link_layer,Stage.width-30,y_loc,6,10,0); 			}			else {				end_point = {x:endObj._width/2, y:endObj._height/2};				endObj.localToGlobal(end_point);			}			_root.link_layer.lineStyle(0, color, 75);			if(style == "dash") {				this.dashTo(_root.link_layer,start_point.x, start_point.y,end_point.x, end_point.y,3,3,0,color,75);			}			else {				_root.link_layer.moveTo(start_point.x, start_point.y);				_root.link_layer.lineTo(end_point.x, end_point.y);			}		}	}		/**		* dashTo		* Draws a dashed line from the point x1,y1 to the point x2,y2		* The line may is drawn on the movie clips specified by the 		* <em>target</em> parameter (default is _root).  The line may 		* be any color or transparency and width, length of dashes, 		* and space between dashes may all be specified.		* 		* @param target MovieClip the movie clip on which the dashed 		* line will be drawn.		* @param x1 Number starting position on x axis - <strong></strong>required</strong>		* @param y1 Number starting position on y axis - <strong></strong>required</strong>		* @param x2 Number finishing position on x axis - <strong></strong>required</strong>		* @param y2 Number finishing position on y axis - <strong></strong>required</strong>		* @param dashLength [optional] Number the number of pixels long each dash 		* will be.  Default = 5		* @param spaceLength [optional] Number the number of pixels between each 		* dash.  Default = 5		* @param strokWidth [optional] Number the width of each dash. 		* Default = 1		* @param rgbHex [optional] the Hex color value of the dashed line.  		* Default = 0x000000		* @param alpha [optional] Number the alpha transparancy that the dashed 		* line will have. Default = 100;		*/		public function dashTo(target:MovieClip, x1:Number, 			y1:Number,x2:Number, y2:Number, dashLength:Number, 			spaceLength:Number ):Void			{				if ( arguments < 5 ){					trace("com.polymercode.Draw.dashTo - too few parameters.");					return;				}				if ( spaceLength == undefined )				spaceLength = 5;				if ( dashLength == undefined )				dashLength = 5;				var x = x2 - x1;				var y = y2 - y1;				var hyp = Math.sqrt((x)*(x) + (y)*(y));				var units = hyp/(dashLength+spaceLength);				var dashSpaceRatio = dashLength/(dashLength+spaceLength);				var dashX = (x/units)*dashSpaceRatio;				var spaceX = (x/units)-dashX;				var dashY = (y/units)*dashSpaceRatio;				var spaceY = (y/units)-dashY;				target.moveTo(x1, y1);				while (hyp > 0) {					x1 += dashX;					y1 += dashY;					hyp -= dashLength;					if (hyp < 0) {						x1 = x2;						y1 = y2;					}					target.lineTo(x1, y1);					x1 += spaceX;					y1 += spaceY;					target.moveTo(x1, y1);					hyp -= spaceLength;				}				target.moveTo(x2, y2);			}			/**			* a method for creating polygon shapes.  Negative values will draw 			* the polygon in reverse direction.  Negative drawing may be useful 			* for creating knock-outs in masks.			* 			* @param target the MovieClip that the polygon is to be drawn on			* @param x x coordinate of the center of the polygon			* @param y y coordinate of the center of the polygon			* @param sides the number of sides (must be > 2)			* @param radius the radius from the center point to the points			* on the polygon			* @param angle [optional] the starting offset angle (degrees) from			* 0. Default = 0			* 			* based on mc.drawPoly() - by Ric Ewing (ric@formequalsfunction.com) - version 1.4 - 4.7.2002			*/			public function polygon(target:MovieClip, x:Number, 				y:Number, sides:Number, radius:Number, angle:Number):Void 				{					if (arguments.length<5)					{						trace("com.polymercode.Draw.polygon - too few parameters");						return;					}					if ( angle == undefined )					angle = 0;					// convert sides to positive value					var count = Math.abs(sides);					// check that count is sufficient to build polygon					if (count>2) {						// init vars						var step, start, n, dx, dy;						// calculate span of sides						step = (Math.PI*2)/sides;						// calculate starting angle in radians						start = (angle/180)*Math.PI;						target.moveTo(x+(Math.cos(start)*radius), y-(Math.sin(start)*radius));						// draw the polygon						for (n=1; n<=count; n++) {							dx = x+Math.cos(start+(step*n))*radius;							dy = y-Math.sin(start+(step*n))*radius;							target.lineTo(dx, dy);						}					}				}				// Stub				function drawFeatures(withLabels:Boolean,inRows:Boolean, showScale:Boolean) {					trace("rendering features for " + this._name);					//trace("rendering features for " + this.chromosome);					if(this.isZoomed == "yes") {						//trace("Chromosome zoomed!" + this._name);						withLabels = _root._labelFeaturesOnZoomView;						inRows = Boolean(false); // If we are zoomed then dont compress					}					else {						//trace("Chromosome not zoomed!" + this._name);						withLabels = _root._labelFeaturesOnGenomeView;					}					this.featureList.sort(this.sortFeaturesByType); // sort the feature list					for (var f = 0; f< this.featureList.length; f++) {						this.featureList[f]._x = this.chrWidth; // return to home position						this.featureList[f].drawFeature(withLabels);					}					this.featureDrawIndex = 0;					// var showScale:Boolean = true;					if(showScale) {						this.lineStyle(1, 0xffffff, 100);						// draw a vertical line the length of the chromosome						/*						this.moveTo(-5,0);						this.lineTo(-5,(this.chr_length/this.scaleFactor) );						*/						// tick marks down the chromosome, spaced every 'tickSpacing' units						/*						for(var tick:Number=0; tick < (this.chr_length/tickSpacing); tick++) {							trace("Tick: " + tick + ", tickSpacing = " + tickSpacing);							this.moveTo(-5, (tick * tickSpacing/this.scaleFactor) );							this.lineTo(-3, (tick * tickSpacing/this.scaleFactor) );						}						*/						//cap the line at the end of the chromosome						//this.moveTo(-5,(this.chr_length/this.scaleFactor));						//this.lineTo(-3,(this.chr_length/this.scaleFactor) ); //new_mc.chr_length/scaleFactor					}					if(_root.animatedPacking) {						if(this.featureList.length != 0 ) {							this.onEnterFrame = function() {								var xIncrement:Number = 2;								//trace("onEnterFrame: rendering " + this._name);								//trace(this._name + "Drawing, num features: " + this.featureList.length);								if(this.featureDrawIndex == this.featureList.length) {									//trace("All features moved, removing onEnterFrame");									delete this.onEnterFrame;								}								var currentFeature:Feature = this.featureList[0];								//trace("Render loop: real array: " + this.featureList.length);								//trace("Render loop: current feature to move: " + currentFeature.label + ", x: " + currentFeature._x);								//trace("Render loop: settings: inRows" + inRows );								// If we are aligning in rows, just move to the appropriate row, as defined by								// a preset _X coordinate. Nice to pass this in from config file to allow								// different arrangements and more types of features.								if(inRows) {									this.featureList[this.featureDrawIndex]._x = this.chrWidth+2;									switch (this.featureList[this.featureDrawIndex].type) {										case "gene":										//this.featureList[this.featureDrawIndex]._x += 5;										break;										case "qtl":										this.featureList[this.featureDrawIndex]._x += 6;										break;										default:										//this.featureList[this.featureDrawIndex]._x += 5;										break;									}									this.featureDrawIndex++;									// delete this.onEnterFrame; // stop here for this feature								}								else {									// past the minimum distance, check for hits with other features									if(this.featureList[this.featureDrawIndex]._x > (this.chrWidth+5) ) {										//trace("x pos ok");										// check hit with all other features in chromosome, except this one										var missAll:Boolean = true;										for(var g=0; g< this.featureList.length; g++) {											// for all the other 											// ignore this feature itself and others that are of different types.&& (this.featureList[this.featureDrawIndex].type == this.featureList[g].type)											if((this.featureList[this.featureDrawIndex]._name != this.featureList[g]._name)  ) {												// if we hit a feature, keep moving right.												if(this.featureList[this.featureDrawIndex].hitTest(this.featureList[g])) {													this.featureList[this.featureDrawIndex]._x += xIncrement;													trace("        " + this.featureList[this.featureDrawIndex].label + " hits " + this.featureList[g].label + ", keep moving");													missAll = false; // still dont miss everything												}												// otherwise, we're past 25px, dont hit any other feaures, stop moving,												else {													//trace("        " + this.featureList[this.featureDrawIndex].label + "misses " + this.featureList[g].label + ", were done");													// this.featureList.shift(); // remove this feature from the list												}											}										}										if(missAll) {											//this.featureList[this.featureDrawIndex]._x += 3; // add one just to give some spacing											//trace(this.featureList[this.featureDrawIndex].label + "misses everything, were done");											// redraw feature hilites if turned on											this.featureList[this.featureDrawIndex].checkHilites();											this.featureDrawIndex++;											// delete this.onEnterFrame;										}									}									// less than 25px, keep moving right									else {										this.featureList[this.featureDrawIndex]._x += xIncrement;										//trace("x pos increase" + this.featureList[0]._x);									}								}							};						}					}				}				public function drawChromosome():Void {					trace("Drawing chromosome");					var new_chr:MovieClip = this.attachMovie("GenericMC", "chr_mask_mc", 100);					new_chr.lineStyle(0, 0x000000, 100);					new_chr.beginFill(0xFFFFFF, 100);					new_chr.drawRect(0, 0, this.chrWidth, this.chr_length/scaleFactor, 5);					new_chr.endFill();					// Black outline of chromosome					var new_chr_outline:MovieClip = this.attachMovie("GenericMC", "chr_outline_mc", 1000);					new_chr_outline.lineStyle(0, 0x000000, 100);					new_chr_outline.drawRect(0, 0, this.chrWidth, this.chr_length/scaleFactor, 5);					new_chr.lineStyle(2, 0x000000, 100);					// Loop through the bands and their positions to create the banding pattern					var bandHolder = this.attachMovie("GenericMC", "band_holder_mc", 50);					var chrBands:Array = _parent.cytoIdeo_chr_ds.currentItem.band;					trace("Bands: "+chrBands.length);					var lastBandLength = 0;					for (var b = 0; b<chrBands.length; b++) {						var bandData:Array = _root.xParse(chrBands[b]);						// trace("XML: " + chrBands[b]);						var bandStart = 0;						if (bandData["start"]>0) {							bandStart = bandData["start"]/scaleFactor;						}						var bandWidth:Number = this.chrWidth;						var bandHeight:Number = (bandData["end"]/scaleFactor)-bandStart;						var bandColor = null;						// if color is defined in the file						if(bandData["color"]) {							bandColor = bandData["color"];						}						var testBand:Band = Band.createBand(bandHolder, bandHolder.getNextHighestDepth(), 5, 12, 1, bandData["name"],this.chromosome, bandData["start"], bandData["end"], bandData["stain"], bandColor,  bandData["link"]);						testBand.drawBand(bandWidth,bandHeight);						testBand._x = 0;						testBand._y = bandStart;						// Probably have to loop through all the bands to set the mask here						lastBandLength = bandData["end"];					}					bandHolder.setMask(new_chr);				}				public function zoomIt() {		// this.startDrag(false);		trace("Clicked: " +this._name + ", home x: " + this.homeX + ", home y: " + this.homeY);		this.isHomePosition = !this.isHomePosition;		if(_root.zoomStyle == "rotate") {			this.isRotated = "yes";		}		else {			this.isRotated = "no";		}		// need to move back to home		if(this.isHomePosition == false) {			this.bar._visible = false; // hide on main view			// show all the chromosomes			/*			for (var c = 0; c< chromosomeList.length; c++) {				//trace("Showing " + chromosomeList[c]._name);				chromosomeList[c]._visible = true;			}			*/			_root.showAllChromosomes();			// move to home position			this._x = this.homeX;			this._y = this.homeY;			this._yscale = 100;			this._xscale = 100;			if(_root.zoomStyle == "rotate") {				this._rotation = 0;				this.isRotated = "yes";			}			else {				this.isRotated = "no";			}			// set alpha to dim if no annotations			if(this.featureList.length) {				this._alpha = 100;			}			else {				this._alpha = _root.dimChrAlpha;			}			this.isZoomed = "no";			this.drawFeatures(_root._labelFeaturesOnGenomeView, true, false);			_root.proxy.call("unzoomChromosome",this.chromosome, new Object());		}		else {			if(this.bar == undefined) {				this.bar = BarSelector.createBarSelector(this, this.getNextHighestDepth(), -6, 0, 3, (this.chr_length/this.scaleFactor), "123", this.chr_length);			}			this.bar._visible = true;			// hide the other chromosomes			/*for (var c = 0; c<chromosomeList.length; c++) {				if (this._name != chromosomeList[c]._name) {					//trace("HIding " + chromosomeList[c]._name);					chromosomeList[c]._visible = false;				}			}			*/			_root.hideAllChromosomesButOne(this._name);			this.isZoomed = "yes";			// move to top left.			var newScaleFactor:Number;			// _root.zoomStyle = "rotate";			if(_root.zoomStyle == "rotate") {				/* Rotate it */				var newScaleFactor:Number = (Stage.width/this._height)*90;				this._yscale = newScaleFactor; // make it bigger				this._xscale = newScaleFactor;				this._rotation = -90;				this._x = 15+(this.number_txt._height); // make sure the chromosome number is visible				this._y = Stage.height-35;			}			else {				newScaleFactor = 190;				// base things off the first chromosome length - the longest in theory				// newScaleFactor =(_root._longestChromosomeLength/this.chr_length)*90;				// newScaleFactor = (Stage.height/this._height)*90;				this._yscale = newScaleFactor; // make it bigger				this._xscale = newScaleFactor;				// Move to the top left				this._x = 20;				this._y = 30;			}			this._alpha = 100;			// Use _labelFeatures to turn labels on or off via prefs.			this.drawFeatures(_root._labelFeaturesOnZoomView, false, false);			_root.proxy.call("zoomChromosome",this.chromosome, new Object());		}	};}